# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Тычков Дмитрий Евгеньевич
- ИНО-ОЗБ-ПОАС-22-2

| Задание    | Лаб_раб | Сам_раб |
|------------|---------|---------|
| Задание 1  | +       | +       |
| Задание 2  | +       | +       |
| Задание 3  | +       | +       |
| Задание 4  | +       | +       |
| Задание 5  | +       | +       |
| Задание 6  | +       | +       |
| Задание 7  | +       | +       |
| Задание 8  | +       | +       |
| Задание 9  | +       | +       |
| Задание 10 | +       | +       |
| Задание 11 | -       | -       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- 

## Самостоятельная работа №1
#### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. Подсказка: необходимо использовать модуль time 
#### Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы. 
### Результат
```python
import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения {func.__name__}: {execution_time} секунд")
        return result
    return wrapper

@measure_time
def fibonacci():
    fib1 = fib2 = 1

    for i in range(2, 200):
        fib1, fib2 = fib2,fib1 + fib2

        print(fib2, end=' ')
        print('\n')


if __name__ == '__main__':
    fibonacci()
```
![Меню]()
### Выводы
#### Делаем декоратор, в его теле записываем время старта функции фибоначчи, запускаем фибоначчи, записываем время финиша, затем высчитываем разницу и выводим на экран.

## Самостоятельная работа №2
#### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла

### Результат
```python
def read_file(filename):
    try:
        with open(filename, "r") as file:
            data = file.read()
            if not data:
                raise Exception("Файл пустой")
            else:
                print("Информация из файла:")
                print(data)
    except FileNotFoundError:
        print("Файл не найден")
    except Exception as e:
        print("Ошибка:", e)

print("Попытка считать данные:")
read_file("text/emptyFile.txt")

print("Попытка считать данные:")
read_file("text/dataFile.txt")

print("Попытка считать данные:")
read_file("text/none.txt")
```
![Меню]()
### Выводы
#### Обрабатываем 3 ситуации. 1)Файл пустой, 2)Файл не пустой - вывод данных на экран, 3) Файла нет в каталоге, оповещаем об отсутствии файла.

## Самостоятельная работа №3
#### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль

### Результат
```python
def calculate_with_except():
    try:
        number = int(input("Введите число: "))
        result = 2 + number
        print("Результат сложения:", result)
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")


print("Тест 1: ввод числа")
calculate_with_except()

print("\nТест 2: ввод строки")
calculate_with_except()

print("\nТест 3: ввод другого неподходящего типа данных")
calculate_with_except()
```
![Меню]()
### Выводы
#### Для обработки ошибки был выбран эксепшн "ValueError" так как полностью подходит под требования задачи.

## Самостоятельная работа №4
#### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

### Результат
```python
# Определение декоратора
def logging_decorator(func):
    # В этой строке определяется декоратор, который принимает функцию func в качестве аргумента

    def wrapper(*args, **kwargs):
        # Внутри декоратора определяется внутренняя функция wrapper, которая будет обертывать вызов функции func
        # *args и **kwargs позволяют передавать произвольное количество позиционных и ключевых аргументов

        print(f"Вызвана функция {func.__name__} с аргументами: {args}, {kwargs}")
        # Здесь выводится сообщение о вызове функции, указывая ее имя и переданные аргументы

        result = func(*args, **kwargs)
        # Вызывается оригинальная функция func с переданными аргументами

        print(f"Результат выполнения функции {func.__name__}: {result}")
        # Здесь выводится сообщение о результате выполнения функции

        return result
        # Возвращается результат выполнения оригинальной функции

    return wrapper
    # Возвращается внутренняя функция wrapper в качестве декоратора

# Использование декоратора для первой функции
@logging_decorator
def greet(name):
    # Это первая функция, к которой применен декоратор logging_decorator

    return f"Привет, {name}!"
    # Функция просто формирует строку приветствия с переданным именем и возвращает ее

# Использование декоратора для второй функции
@logging_decorator
def calculate_product(a, b):
    # Это вторая функция, к которой применен декоратор logging_decorator

    return a * b
    # Функция возвращает произведение двух переданных чисел

# Тесты
greeting = greet("Дима")
# Вызывается функция greet с аргументом "Дима", она обернута в декоратор logging_decorator
# Выводится сообщение о вызове функции с аргументом
# Выводится сообщение о результате выполнения функции
# Результат выполнения (строка приветствия) присваивается переменной greeting
print(greeting)
# Результат выполнения функции greet выводится на экран

result = calculate_product(3, 5)
# Вызывается функция calculate_product с аргументами 3 и 5, она обернута в декоратор logging_decorator
# Выводится сообщение о вызове функции с аргументами
# Выводится сообщение о результате выполнения функции
# Результат выполнения (произведение чисел) присваивается переменной result
print("Результат умножения:", result)
# Результат выполнения функции calculate_product выводится на экран с дополнительным текстом
```
![Меню]()
### Выводы
#### Создан декоратор который выводит информацию о старте и о финише переданной функции.

## Самостоятельная работа №5
#### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

### Результат
```python
    def __init__(self, value):
    # Метод __init__ класса NegativeValueError, который инициализирует объект исключения
    # Он принимает аргумент value, который представляет отрицательное значение
    self.value = value
    # Здесь устанавливается значение атрибута value для объекта исключения

def __str__(self):
    # Метод __str__ класса NegativeValueError, который возвращает строку с описанием ошибки
    return f"Ошибка: значение {self.value} отрицательное."
    # Здесь формируется строка с описанием ошибки, включающая отрицательное значение

# функция, которая проверяет переданное число и выбрасывает исключение, если оно отрицательное
def process_value(value):
    # Определение функции process_value, которая принимает значение для проверки
    if value < 0:
        # Проверка, является ли значение отрицательным
        raise NegativeValueError(value)
        # Если значение отрицательное, выбрасывается исключение NegativeValueError
    else:
        print("Значение корректно.")
        # Если значение не отрицательное, выводится сообщение о корректности значения


try:
    num = int(input("Введите число: "))
    # Запрос ввода числа от пользователя и преобразование его в целое число
    process_value(num)
    # Вызов функции process_value для проверки введенного числа
except NegativeValueError as e:
    # Обработка исключения NegativeValueError
    print(e)
    # Вывод сообщения об ошибке, содержащего значение, вызвавшее ошибку

try:
    a = 10
    b = 15
    process_value(a-b)
except NegativeValueError as e:
    print(e)

```
![Меню]()
### Выводы
#### Создали исключение которое обрабатывает ввыод пользователя, если ввели отрицательное число (Меньше 0) выводит ошибку

